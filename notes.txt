ReactJS and Rails

---
Docker note:
Using the Phusion Passenger image, we need to create our own user in the
Dockerfile,
and specify that it is used in the nginx config:

RUN useradd -s /bin/bash -u1000 rubyapps

In the container, we can then install the gems with
bundle install --path vendor/bundle
---

Architectural Overview
----------------------

Object-Relational Mapping/Active Record

Rails application:

Web request -> View + Controller + Model

# Our React application View layer:

Web request -> JSON API + HTML + CSS/JavaScript
The JSON API returns data. We serve HTML, CSS, and JS

# View technologies:

JBuilder  --- RoR method to generate JSON
ERB       --- generate HTML
Sprockets --- compiles JS to serve via the asset pipeline

We will also use Babel ES6 to transpile into JS.

Isomorphic refactor to serve both client and server side.

Express (Node.js) - for delivering the app
Webpack (Node.js) - JS compilation and serving

--------------------

002 Scaffolding the Rails Application
-------------------------------------

# Create the application
rails new <application_name>

# We remove spring, coffeescript, jquery and turbolinks from the Gemfile

# We add the following gems:
gem 'ancestry'    # quickly and easily model trees
gem 'rails_admin' # helps build admin interface to add/remove records

# Let's create a migration
bundle exec rails g migration create_restaurants

# We'll edit the migration file:

class CreateRestaurants < ActiveRecord::Migration
  def change
    create_table :restaurants do |t|
      t.string :name
      t.string :address
      t.text :description
      t.timestamps
    end
  end
end

# and run the migration:
bundle exec rake db:migrate

# Next, we need to create the model
class Restaurant < ActiveRecord::Base
end

# We can then use the rails_admin generator to make some forms for us:
bundle exec rails g rails_admin:install

# This adds rails_admin as an engine for us. After restarting the rails
# server, we can access the admin page:
localhost:3000/admin

# We add a Comment model, with a belongs_to Restaurant relationship:

class CreateComments < ActiveRecord::Migration
  def change
    create_table :comments do |t|
      t.string :author
      t.text :body
      t.integer :rank
      t.belongs_to :restaurant
      t.timestamps
    end
    add_index :comments, :restaurant_id
  end
end

# The following lines are added to restaurant.rb and comment.rb respectively
# has_many :comments
# belongs_to :restaurant

# We are going to use the ancestry gem to set comments up as trees
# for this, we need a migration with index:

bundle exec rails g migration add_ancestry_to_comments

class AddAncestryToComments < ActiveRecord::Migration
  def change
    add_column :comments, :ancestry, :string
    add_index :comments, :ancestry
  end
end

# We need to modify the comments model for use with ancestry:

class Comment < ActiveRecord::Base
  belongs_to :restaurant
  validates :restaurant, presence: true
  has_ancestry
end

# In a Rails console, we can create a child comment:
Comment.create(author: "Jane", body: "Quite right!", parent: Comment.find(1),
 restaurant_id: 1)

# And we can inspect the parent's children:
Comment.find(1).children

# and the path:
Comment.find(1).path

------------------------------------------
# After adding a basic route, view and controller we add foundation-rails
gem "foundation-rails"

# We will now use the foundation assets
rails g foundation:install

# we will be prompted to overwrite application.html.erb (fine, we haven't
# changed it anyway)

# We will modify the global application view:
vim app/views/layouts/application.html.erb

That file features a yield statement, where the controller action is
rendered:

<%= yield %>

Editing this file allows us to customize the application look and feel:

  <body>
    <nav class="top-bar foundation-bar" data-topbar>
      <ul class="title-area">
        <li class="name">
          <h1><a href="/">Tofumine Restaurants</a></h1>
        </li>
      </ul>
      <section class="top-bar-section">
        <ul class="right">
          <li>
            <%= link_to "manage restaurants", "/admin" %>
          </li>
        </ul>
      </section>
    </nav>
    <div class="row">
      <div class="large-12 columns">

        <%= yield %>

      </div>
    </div>
  </body>

-------------------------------------------
Building a React Component Inside Rails
-------------------------------------------

We use

gem "react-rails"

After bundle install, we need to restart the rails server, and to run
the react-rails generator:

rails g react:install

This creates:

app/assets/javascripts/components
app/assets/javascripts/components.js

and it also inserts lines into app/assets/javascripts/application.js

//= require react
//= require react_ujs
//= require components

# So, let's create our first component (think of it as a class)
# app/assets/javascripts/components/comment.js.jsx

var Comment = React.createClass({   // create a JS pseudoclass
  propTypes: {                      // attribute to declare expected input
    author: React.PropTypes.string,
    body: React.PropTypes.string,
    rank: React.PropTypes.number
  },

  render: function() {              // this is required
    return(
      <div>
        <div> Author: {this.props.author}</div>
        <div> Body: {this.props.body}</div>
        <div> Rank: {this.props.rank}</div>
      </div>
    );
  }
});

JSX is a JavaScript pre-processor for markup used by the ReactJS community.

We use React.createClass to create a JS pseudoclass

It is good practice to use a propTypes attribute to indicate expected input to
other component users.

We MUST declare a render function. JSX allows us to incorporate JS into the template.

The React-Rails helper allows us to use components in view ERB files:

<%= react_component('Comment', {author: 'Mr X', body: "Splendid!", rank: 5}) %>


-------------------------------------------------------
007 Preparing JSON Data for ReactJS
-------------------------------------------------------

Our Restaurant model has many comments.

While we could iterate over the comments and pass them to our new react
component, we would like to have a dynamically generated set of comments;
in that case, we need another React component, which we will call
CommentList.

# app/views/restaurants/show.html.erb
<div class="row">
  <h1><%= @restaurant.name %></h1>
</div>
<div class="row">
  <div class="columns medium-6">
    <p>
      <%= @restaurant.description %>
    </p>
  </div>
  <div class="columns medium-6">
    <h3>Comments</h3>
    <%= react_component('CommentList', { comments: raw( render( template: 'comments/index.json.jbuilder')) }) %>
  </div>
</div>

We need to be able to pass data to the new React component. The component
will not be able to understand Rails @comments variable directly; we will
need to pass JSON data instead. We will use JBuilder to make the JSON.

We also need to tell rails that we are using raw JSON, so that it is not
escaped. We render a json.jbuilder template using the @comments variable,
together with a partial: _comment.json.jbuilder.

# app/views/comments/index.json.jbuilder
json.array! @comments, partial: 'comments/comment', as: :comment

# app/views/comments/_comment.json.jbuilder
json.(comment, :id, :body, :author, :rank)

If we inspect the page source now, we will see any comments rendered as JSON.

-------------------------------------------------------
008 Rendering Ruby Models in React
-------------------------------------------------------

Next we need to implement the CommentList component.

First attempt; NOTE that we need to JSON.parse the comments props to use map:

# app/assets/javascripts/components/comment_list.js.jsx
var CommentList = React.createClass({
  render: function() {
    return (
      <div>
        {JSON.parse(this.props.comments).map(function(comment) {
          return (<div> {comment.author} </div>);
        })}
    );
  }
});


Let's return our existing Comment component, rather than the divs.

# app/assets/javascripts/components/comment_list.js.jsx
var CommentList = React.createClass({

  render: function() {
    return (
      <div>
        {JSON.parse(this.props.comments).map(function(comment) {
          return (<Comment key={comment.id} rank={comment.rank} body={comment.body} author={comment.author} />);
        })}
      </div>
    );
  }
});

This is quite verbose; we can use a destructor to simplify:

# app/assets/javascripts/components/comment_list.js.jsx
var CommentList = React.createClass({

  render: function() {
    return (
      <div>
        {JSON.parse(this.props.comments).map(function(comment) {
          return (<Comment key={comment.id} {... comment} />);
        })}
      </div>
    );
  }
});

The {... comment} destructor takes the comment and maps it into the comment
component. This is analogous to a Ruby splat.
